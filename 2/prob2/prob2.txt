package main

import (
	"fmt"
	"math"
	"os"
	"strconv"
	"strings"
)

func removeElement(slice []int, index int) []int {
	if index < 0 || index >= len(slice) {
		return slice
	}
	// Create a new slice to avoid modifying the original
	newSlice := make([]int, len(slice))
	copy(newSlice, slice)
	return append(newSlice[:index], newSlice[index+1:]...)
}

func isAllDecreasing(numbers []int) (bool, int) {
	result := 0
	affectedNumber := 0
	prevNumber := -1
	for pos, number := range numbers {
		if prevNumber == -1 {
			prevNumber = number
			continue
		}
		if number > prevNumber {
			if result >= 1 {
				return false, 1
			}
			result += 1
			affectedNumber = pos
			continue
		}
		prevNumber = number
	}
	return result <= 1, affectedNumber
}

func isAllIncreasing(numbers []int) (bool, int) {
	result := 0
	affectedNumber := 0
	prevNumber := -1
	for pos, number := range numbers {
		if prevNumber == -1 {
			prevNumber = number
			continue
		}
		if number < prevNumber {
			if result >= 1 {
				return false, 1
			}
			result += 1
			affectedNumber = pos
			continue
		}
		prevNumber = number
	}
	return result <= 1, affectedNumber
}

func checkAdjacentLevels(numbers []int) (bool, int) {
	result := 0
	affectedNumber := 0
	prevNumber := -1
	for pos, number := range numbers {
		if prevNumber == -1 {
			prevNumber = number
			continue
		}
		diff := int(math.Abs(float64(number) - float64(prevNumber)))
		if diff < 1 || diff > 3 {
			if result >= 1 {
				return false, 1
			}
			result += 1
			affectedNumber = pos
			continue
		}
		prevNumber = number
	}
	return result <= 1, affectedNumber
}

func main() {
	// Read the entire file into a byte slice
	data, err := os.ReadFile("../numbers.txt")
	if err != nil {
		fmt.Println("Error reading file:", err)
		return
	}

	// Convert the byte slice to a string and split by lines
	lines := strings.Split(string(data), "\n")
	// Remove the last element
	if len(lines) > 0 {
		if lines[len(lines)-1] == "" {
			lines = lines[:len(lines)-1]
		}
	}

	safeLines := 0

	// Iterate over each line
	for lineNum, line := range lines {
		// Prepare a slice to hold all numbers
		var numbers []int
		// Split the line by spaces
		fields := strings.Fields(line)
		for _, field := range fields {
			// Convert each field to an integer
			num, err := strconv.Atoi(field)
			if err != nil {
				fmt.Println("Error converting string to int:", err)
				continue
			}
			numbers = append(numbers, num)
		}
		allDec, allDecNum := isAllDecreasing(numbers)
		allInc, allIncNum := isAllIncreasing(numbers)
		checkAdj, checkAdjNum := checkAdjacentLevels(numbers)
		if lineNum > 40 && lineNum < 60 {
			fmt.Println(numbers)
			fmt.Printf("All Decreasing: %t, Count: %d\n", allDec, allDecNum)
			fmt.Printf("All Increasing: %t, Count: %d\n", allInc, allIncNum)
			fmt.Printf("Check Adjacent: %t, Count: %d\n", checkAdj, checkAdjNum)
		}
		if (allDec || allInc) && checkAdj {
			if allDec {
				condition := (allDecNum == 0 || checkAdjNum == 0) || allDecNum == checkAdjNum
				if condition {
					safeLines++
					if lineNum > 40 && lineNum < 60 {
						fmt.Println("New safe line1")
					}
				} else {
					// Try isAllDecreasing without checkAdjNum
					newNumbers := removeElement(numbers, checkAdjNum)
					prevDecNum := allDecNum
					allDec, allDecNum = isAllDecreasing(newNumbers)
					if allDec && allDecNum == 0 {
						safeLines++
						if lineNum > 40 && lineNum < 60 {
							fmt.Println("New safe line2")
						}
					} else {
						// Try checkAdjacentLevels without allDecNum
						newNumbers = removeElement(numbers, prevDecNum)
						checkAdj, checkAdjNum = checkAdjacentLevels(newNumbers)
						if checkAdj && checkAdjNum == 0 {
							safeLines++
							if lineNum > 40 && lineNum < 60 {
								fmt.Println("New safe line3")
							}
						}
					}
				}
			}
			if allInc {
				condition := (allIncNum == 0 || checkAdjNum == 0) || allIncNum == checkAdjNum
				if condition {
					safeLines++
					if lineNum > 40 && lineNum < 60 {
						fmt.Println("New safe line4")
					}
				} else {
					// Try isAllIncreasing without checkAdjNum
					newNumbers := removeElement(numbers, checkAdjNum)
					prevIncNum := allIncNum
					allInc, allIncNum = isAllIncreasing(newNumbers)
					if allInc && allIncNum == 0 {
						safeLines++
						if lineNum > 40 && lineNum < 60 {
							fmt.Println("New safe line5")
						}
					} else {
						// Try checkAdjacentLevels without allIncNum
						newNumbers = removeElement(numbers, prevIncNum)
						checkAdj, checkAdjNum = checkAdjacentLevels(newNumbers)
						if checkAdj && checkAdjNum == 0 {
							safeLines++
							if lineNum > 40 && lineNum < 60 {
								fmt.Println("New safe line6")
							}
						}
					}
				}
			}
		}
	}

	fmt.Println(safeLines)
}
